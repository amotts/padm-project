Needs:

Credit for reference: Pascal Spino and William B Mitchell

- RRT
    - accept a start, goal
    - output a sequence of poses
    - detects collisions
    - find closest node
    - takes step
    - finds random point
    - cuttoff point -> failed

    Steps
    1) check goal and start locations for collisions with obstacles via collision function
    2) create list of rrt nodes
    3) limiting loop for number of iterations until fail
    4) take sample point
    5) find nearest node by using argmin of distance function
    6) get point step distance along line
    7) check point for collision with collision function
    8) if no collision: add to queue and check if is goal state. if so return path




    Notes:
    Did not include "extend" or consider any midway points, currently not limited by phsyical constraints on angle movements
    Need step function to find point one step away in direction of sample
    implemented a percentage goal: random percent of the time, select the goal as the sample, increases speed of finding target
        - in simple cartesian, when from 170 nodes explored with %=0.0 to ~50 nodes explored with %=0.33


Helper func todo:
    # dist_func 
    # take_step - linear scaling of each dimension
    # sample_func - provided 
    # collision_func - unclear exactly what its hitting. May need to include or discount certain obstacles either in collision function or when adding them to the obstacles list
    # goal_func - default to not needing


MOVED ALL RRT FUNCTIONS TO SEPERATE PY FILE






Future Thoughts:
create dictionary of locations and their respective locations and use the second/third/fourth word of input argument to get the targets for each action.
minimal example uses format of having a get_XXXXX_func to create functions so i guess that must be the best way to do it

Getting into collision with 3? unknown what it is. 0 is kitchen_part_right. 1 is "plane". 2 is world.robot